
——————————————*/ /*——————————————
------------- CONCEPT HERE (EXAMPLE:JAVA SCRIPT IN HTML)-------------
FACTS:
-It must be done like this. .
-Use lower case . .
USE IT WHEN:
-You want to change the background of a screen to diff colors.
-You want to get input from a customers.
EXAMPLE:
if (code here)
  do this
console.log(something here)
CHALLENGE:
Write a page with 9 squares and a changing background color.


/*—————————————— May 30, 2014 ——————————————*/
—————RUBY
-CRuby is built in C. JRuby is built in Java and runs on the JVM.
-One of Ruby's downsides is poor memory managment and it's speed at large sizes.
-Rubinius is built in Ruby.

—————-DEBUGGING
-See day 9 video. May 30, 2014
-It will be very common to use the raise command to debug.
-Debugging tools - pry is one.
-To set up a gem for a program: create a file in that directory called 'Gemfile' with a capital G and put something like the following in it:
source "https://rubygems.org"
gem "pry"

-u bundle every time add a new gem.
-put 'binding.pry' into your code to have binding use the gem 'pry' to run and debug cool stuff.
-make sure to bundle from the terminal from the directory your in simply by typing "bundle"


CHALLANGE:
1.open up tictactoe app
2.add a gemfile by going to Atom/ file/ new/ give it the name "Gemfile" with a capital "G"/ save it/

3.add in the "pry" gem by typing in : source "https://rubygems.org" and on the next line: gem "pry"
4.require "pry" in your game setup by typing " require "pry" " on the top line.
5.use the binding.pry at some point in the game and play with pry by typing" "binding.pry" somewhere in your code and watch what happens when you run it.


—————————————— May 29, 2014 Day 8——————————————
GITHUB
-Use git add -A to add all files in a folder at once.

FILE I/O
-gets and puts is basic file i/o stuff
-In ibr:
"Dir.pwd" returns what "pwd" would return in but as a string. This also makes it dynamic instead of static and it makes it easier to require files.
-Dir.glob("*.rb") returns an array of file names so we can iterate over these file names and then do "require" on one of the files.
-we can run "ls" in ruby have to tell it that it's a ruby command and not a system command: system("ls").
-can also do it for pwd and other common commands.
-use backtics `` for shorthand. `ls`
-fun: `say -v
-fun: do name = Kenny then `say -v "Hello #{name}"
-http://apidock.com/ruby/Dir for reference
-Dir.chdir is same as doing "cd" in terminal.
-"File" - File.exists?("car.rb") tell me if a file currently exists in the currently directory.
-Dir.exists?("some_director") tells u if a dir exists or not.
- http://apidock.com/ruby/File for info on "File."
-Create a new file:
new_file = File.new("first_file.txt") give u an error cuz ur computer needs to know the type of mode for creating a file. online ref: http://apidock.com/ruby/IO
So use: File.new("first_file.txt","w+") which puts us in the right mode and returns an instance of the file..?
-new_file.write("hello") writes text to the file? the return value will be the number of bytes written to the file.
-When you open a file, you have to close it when ur done. Use: new_file.close to do this.
-To read each line indiviually and returned seperately use a Ruby built-in method File.readlines. ex: File.readlines("first_file.txt"). Then assign it to a variable like: line=File.readlines("first_file.txt"). Then do lines.eac do |line| then puts line.upcase and end to print out.

YAML FILE TYPES
-Is a plain text file that has a specific structure to how you format ur text.
-yml files aren't really a ruby thing. php, pytheon all interact with yml files. it's just a plain text file.
-To use a yaml parser, use require 'yaml'
-This to get a hash:
2.1.2 :003 > YAML
 => Psych
2.1.2 :004 > YAML.load_file("contacts.yml")
 => {"contacts"=>[{"name"=>"Kenny", "hobby"=>"coding"}, {"name"=>"Linda", "hobby"=>"loving Kenny"}, {"name"=>"Ar", "hobby"=>"bugging Bella"}, {"name"=>"Bella", "hobby"=>"teasing Ari"}]}

-When we write to a file, we're using a string.

—————CHALLENGE
-Create an address book in ruby.
0. write a program called "friends.rb"
1. create a hash with some information about your neighbor, and yourself.
2. create a new yaml file called "friends.yml"
3. write that hash to the yaml file. *note be sure to close the file.
4. Running "ruby friends.rb" should generate this file.
Mine:
# 0. write a program called "friends.rb"
require 'yaml'
# 1. creaet a hash with some information about your neighbor, and yourself.
#friends = {"neighbor" => "alien", "kenny" => "president"}
my_array = [
  {name: 'jeremy', age:32},
  {name: 'ty', age:27}
]

# 2. craet a new yaml file called "friends.yml"
#File.new("friends.yml" "w+")
new_file = File.new("friends.yml", "w+")

# 3. write that hash to the yaml file. *note be sure to close the file.
#YAML.load_file("friends.yml")
new_file.write(my_array.to_yaml)
new_file.close

# 4. Running "ruby friends.rb" should generate this file.

#better way:
# File.new("friends.yml", "w+") do |f|
#   f.write(my_array.to_yaml)
# end

---GEMS:
rubygems.org
in terminal use: gems list to see all gems u have. use gem -v for version.

-----INCRYPTION


/*—————————————— May 28, 2014 ——————————————*/
TERNARY OPERATOR:
x = 4
y = 5
x < y ? "yes" : "nope"
-Could also store it in a variable like:
result = x < y ? "yes" : "nope"
-And this is why you can't put a "?" at the end of a variable. Ruby thinks ur trying to use a turnary operator.

CLASSES REVIEW:
-The whole reason we have classes is becasue the allow us to put down our thoughts into code in a more organized fashion, like grouping things in a like fashion like users on a website like facebook for example a user may need to have an email and name but without a class, we can't call them a user. The email and name they just put in is not assoiated with an object, it's just two random pieces of data but if we have a "User Class" with and email attribute and a name attribute, we know that it's "User" information.

LINKING TO FILES:
- Use "require" like:
require 'date'
-if it's a file that ends in .rb, we don't need to put it as Ruby knows it.
- only need to do it once.

example with date object after we've required it.
- date.method to find out all the methods that can be used on it.
- date.to_s
- require 'net/http' to connect to internet.

MAKING NEW FILES:
- The Load Path which is an array of strings which are a path to where ruby stores all these files. so ruby knows where "date.rb" and others are located on ur machine but it doesn't know where first.rb is so we have to tell it where it is so it can load it into the array of strings.
Use "require_relative" which says the file should be close around me somewhre. As long as it's in the same directory, it'll find it.
Order of how you run the "require" files matters if there are dependencies

LOAD PATH:
$load_path? shows the array of the directories where ruby files may be.
to add our new file to the array

MODULES & MIXES:
-Ruby can't do multiple inheritance
-Modules are also contants and begin with a cap letter.
-Can put as many methods into a module as you want.
ex:
module Transportation
  def going_forward
    puts "moving forward"
  end
end

INCLUDE & EXTEND:

SCOPING CONTANTS:
Kenny::Person

CLASS EXORCISE:
-Do tictactoe with require method like a board.rb or a class for x or o, create new instnace of each that inherit from a player class etc.
class Player
  def wins?(marker) #this takes the marker and returns true or false


/*—————————————— May 27, 2014 day 6——————————————*/
-conditional operators are: <, >, +, = etc
-comparison operators are: &&, ||
-alternative to using an if statement is a case statement.
CREATING A METHOD:
- Start with "def":
def does_x_win
end
or:
def grab_food
  puts "grabbing food"
  puts "and it's good"
end

-Blocks of code are scopes that define everything.
-Put () next to your new defined method to make it dynamic:
def grab_food(food)
  puts "grabbing some #{food}"
end
-call this method by:
grab_food("sushi")
-"wrong number of arguments (0 for 1)" means you didn't put in the required amount of arguments. Will also get (1 for 2) if there are two required arguments and you're only passing 1. ie grab_food ("sushi") instead of grab_food("sushi", "juice")
-Pass multiple arguments on a method by:
def grab_food(food, drink)
  puts "grabbing some #{food}"
  puts "grabbing some #{drink}"
end
-Variables have different scopes. Local variable are only accessable inside the block/scope where it's created.
-Making this dynamic looks like this:
meals = [
  {food: 'pizza', drink: 'beer'}
  {food: 'sushi', drink: 'sake'}
  {food: 'pasta', drink: 'wine'}
]

-Call it like this:
meals.each do |meal|
  grab_food(meal[:food], meal[:drink])
end

-Instance variables have @. ie. @meals. And they will have a larger scope and will always be available to us.
-More dynamic example with user input:
meals= []
dinner = {}

puts "Please enter in a food"
food = gets.chomp
puts "Please enter a drink"
drink = gets.chomp

dinner[:food] = food
dinner[:drink] = drink
meals << dinner

meals.each do |meal|
  grab_food(meal[:food], meal[:drink])
end

-NOW ADDING LOOP TO MAKE MORE DYNAMIC:
meals= []
dinner = {}

puts "Please enter in a food"
food = gets.chomp
puts "Please enter a drink"
drink = gets.chomp

dinner[:food] = food
dinner[:drink] = drink
meals << dinner

puts "Enter in another food? [Y] or [N]"
answer = gets.chomp

meals.each do |meal|
  grab_food(meal[:food], meal[:drink])
end
...incomplete... get full code later...

CLASSES
ex:
class Animal

end
-The naming convention for class is - only begin with a capital letter. If it has multiiple words us case like this: CrazyAnimal. Anything that starts with a capital letter is a contant. Variables can change, constants can't. A class is kind of like a Noun, a person,place,thing. It doesn't change. Methods are actions that other animals can also do.
DEFINING METHODS:
ex:
class: Animal (like the Noun)
  def run (like the verbs)
  def eat (like the verbs)
  def hide (like the verbs)

INHERITENCE
ex:
class Human < Animal
  def play_computer_games
-Animal is inheriting traits from Human.
-Other examples:
class Parent
class Child < Parent

class Boat
class Sailboat < Boat

ATTRIBUTE ACCESSORS:
class Chair
  attr_writter :color, :size, :arms, :design, :weight
  attr_reader :color, :size, :arms, :design, :weight
  attr_accessor :color, :size, :arms, :design, :weight
  end
end
-These 3 above are ways to
-attr_writter lets us ASSIGN a value.
-attr_reader lets us RETURN value.
-attr_accessor lets us do BOTH READ AND WRITE.

CREATE A NEW OBJECT OF A CLASS:
class Sandwich
pbj = Sandwich.new

2 TYPES OF METHODS:
1-INSTANCE METHODS:
-A method that you can only call on an INSTANCE of a class, not on the class itself.
ex:
String.length doesn't work because length is an "Instance" method and can only be called on an instance but we're calling it on the class String itself.

2-CLASS METHODS (or class level method):
-A methode that you run directly on the class itself.
ex:
Sandwich.new

-Types of Instance Methods are reader (def age) and writer (def name=(new_name)).
-Methods with a "?" at the end are predicate methods:
def old_enough?
-These only return true or fasle. ie. the .empty? method for arrays.

-die! is another Instance Method. This method means it will be destructive in some way. or it might modify something in some way like making a value upcase forever.

Class Instance Method:
class Human
  def self.evolve
  end

  def Human.evolve
  end

-In Ruby, everything returns a value. The return value from a method will be the last evaluated thing in that method.

-Class Methods are called on the Class itself, not the instance.

Instance Method examples:
reader method:
def age
end

writer method:
def name = (new_name)
end

predicate method:
def old_enough_to_vote?
end

destructive method:
def die!
end

Class method:
def self.evolve
  puts "evolve from monkey to man"
end


INSTANTIATION:
-Creating a new instance of an object.
-This method is called initialize.
ex:

-Review today's class morning video. May 27, 2014
Exorcise:

Class challenge:
Find an object in the class. Define it's actions & attributes.

class Laptop
  def display
  def play_sound
  def run_programs
end

class Laptop
  attr_accessor :color, :size, :speed, :design, :weight
end

-You can put anything inside of a method. examples:
def boy?
  sex == "male"
end

def girl?
  sex == "female"
end

def say_name
  puts self.name
end


Class Challenge:
# make a car object
Class Car

# the car can drive
# the direction it drives should be dynamic
  def drive(direction)
  puts "The car is driving #{direction}"
  end
end

# the car has a year, make and model attrubutes
attr_accessor :year, :make, :model

# instantiate the object
corvette = Car.new

# make the care drive.
# When driving, it should just print out twich dirction it's dirving.
corvette.drive("Super fast forward")

# Assign all the attributes a value for your car.
corvette.year = 2014
corvette.make = "Stingray"
corvette.model = 1.1

-If we tell "initialize" that it takes some set of arguments, then we can tell new that it also takes that number of arguments.
ex:
  def initialize(make, model, year)
    @make = make
    @model = model
    @year = year
  end

my_car = Car.new("corvett", "1.1", 2014)
puts "my car is a #{my_car.make} #{my_car.model} #{my_car.year}"

Class Challenge:
# initialize a git repository and add, commit, and push

# create a personal chef class
# make his name attribute accessible
# make a method called make_toast that accepts a parameter (brown, light brown, burnt, burnt black, etc)
# make a method called make_juice that accepts a parameter (orange, apple, cranberry)
# make a method called make_eggs (1,2,3, etc) and the style (overeasy, scrambled, sunnyside etc)
How do we run the code that we've written?

/*—————————————— May 23, 2014 ——————————————*/
PSUDO CODE, CONDITIONALS,COMPARISON OPERTORS, COMMENTS, CASE STATEMENT, LOOPS,

- How to create a file in atom from the terminal: First get out of irb if in it,
then type <atom "file name">
CONDITIONALS
- If some_condition
    do_stuff
  end
- False and Nill are the only two things in Ruby that equate to false.
Example if statement:
if my_age >20
  puts "Can go to club"
end

COMPARISON OPERTORS: =, =<, > +!,

CONDITIONAL OPERATORS: && for multiple "if" statements. ie:
  if x_in_space_1 && x_in_space_2 && x_in_space_3
    puts "X wins!"
  end
- || for "or"
- else equals "otherwise" in english
- use the Bang "!" symbol to make something "not" like:
  if !your_car_is_working
    hit me up for a ride
  end
- Can use the else operator inline:
  puts "let's grab lunch" unless you_already_ate

ELSIF:
  if your_grade >= 90
    puts "You get an A"
  elsif your_grade >= 80 && your_grade < 90
    puts "You get a B"
  elsif your_grade >= 70 && your_grade < 80
    puts "You get a C"
  else
    puts "You fail"
  end

COMMENTS:
# for one line and
=begin
=end
for multi-line notes. MUST be all the way to the left.

CASE:
Used when you have a lot of choices or options.
code ie:
grade = A
case grade
  when 'A'
    puts "Yay! Ice cream for you"
  when 'B'
    puts "Not too shabby"

LOOPS:
ie: while loops:
code ie:
  while nemo_is_still_lost
    puts "just keep swimming"
  end
PSUDO CODE 3 LITTLE PIGS:
Variables:
  house 1 is straw
  house 2 is sticks
  house 3 is brick
Conditions:
  if house is not brick then,
    the wolf blows it down
    say "you suck"
  otherwise
    the wolf doesn't blow it down
    say "You are made of stone dude! No rent due"
MAKE A CALCULATOR BRANCH

HW - finnish funwithnumbers

hw - finnish number.rb

TICTACTOE PSUDOCODE:
-Create a board =>
-Loop that ends after 9 turns =>
-Determine who's turn it is
  -create player1, player 2
-Player chooses a space
  -Get player input,
  -Define spaces,
  -check to see if spaces are taken.
-Define 8 winning combinations. =>
-Check to see if anyone has one. =>
-After 9 turns, if no one has won, declare a tie.

LIMITED LOOP:
turn = 0
while turn < 9
  puts turn
#need to tell turn to increase it's value here:
  turn += 1
end

can also:

HW - complete through 16 on code academy

/*—————----————— May 22, 2014 —————----—————*/
- PUtting {<someting>} in a string is called interpolation.
- when you use single quotes, it will return EXACTLY what's between them so you can use things like String Interpolation cuz it will show up.
- two other data types beyond strings and fixnums. Arrays & Hash ( {} ) & ":" which is a symbol which is usually looks like :name or :bird & Time.
- Time.now gives us info on time:
: Time.now
 => 2014-05-22 11:57:54 -0600
- Can also use Time.now.year or Time.now.minute

- symbols are used a lot in hashes.
- symbol example:
me = {
:name => "Kenny",
:age => 40,
:age => "tall",
}
puts me[:name]
- add a property to the hash like: me[:sex] = "male"
- also can use {food: 'taco'} instead of {:food => 'taco'} for brevity.
- Convention is to use lowercase for symbols.
- Arrays are collections. you can iterate Arrays which means going over it one by one.
- In ruby you can assign anything you want to a var. So you can assign arrays to a var.
- each item in an array is called an index.
- : people.each do |person|
puts person
end
- : 2.1.2 :037 > things.each do |number|
2.1.2 :038 >     puts number * number
2.1.2 :039?>   end
1
4
9
- Ruby has 4 types of variables: see other note:
- Hash data types:
storage = {"Box 1" => "Stuff", "Box 2" => "More stuff"}
puts storage["Box 1"]
- each key needs to be unique but the values can be the same. still called indexes just not zero based.
- : storage.each_pari do |key, value|
puts "The key is #{key} and the value is #{value}"
end
- apidock.com/ruby


VARIABLES, INSERTING INTO ARRAYS, HASHES

Assign: Find 5 methods for strings in Ruby: .chomp, .delete, .replace, .size, .scan
Assing: Find 5 methods for Fixnums/Integers: .even?, .zero?, .modulo, .abs, .to_s,

- use <numbers.map($:to_i) as a short way changing a string array to integers
- PUtting {<someting>} in a string is called interpolation.
- when you use single quotes, it will return EXACTLY what's between them so you can use things like String Interpolation cuz it will show up.
- two other data types beyond strings and fixnums. Arrays & Hash ( {} ) & ":" which is a symbol which is usually looks like :name or :bird & Time.
- Time.now gives us info on time:
: Time.now
 => 2014-05-22 11:57:54 -0600
- Can also use Time.now.year or Time.now.minute

- symbols are used a lot in hashes.
- symbol example:
me = {
:name => "Kenny",
:age => 40,
:age => "tall",
}
puts me[:name]
- add a property to the hash like: me[:sex] = "male"
- also can use {food: 'taco'} instead of {:food => 'taco'} for brevity.
- Convention is to use lowercase for symbols.
- Arrays are collections. you can iterate Arrays which means going over it one by one.
- In ruby you can assign anything you want to a var. So you can assign arrays to a var.
- each item in an array is called an index.
- : people.each do |person|
puts person
end
- : 2.1.2 :037 > things.each do |number|
2.1.2 :038 >     puts number * number
2.1.2 :039?>   end
1
4
9
- Ruby has 4 types of variables: see other note:
- Hash data types:
storage = {"Box 1" => "Stuff", "Box 2" => "More stuff"}
puts storage["Box 1"]
- each key needs to be unique but the values can be the same. still called indexes just not zero based.
- : storage.each_pari do |key, value|
puts "The key is #{key} and the value is #{value}"
end
- apidock.com/ruby

/*—————————————— May 21, 2014 ——————————————*/
IRB
- To get into irb  - <irb>
- 2.5 is a fixnums and is a float. a decimal is a float.
- in ruby, to get a float (decimal) use at least one decimal. ie.- 5/2.5=2.5
- Use <.class> at the end of a line to know what data type it is. ie- "kenny".class or 345.class or 2.5.class
- 5.downcase doesn't work cuz fixnums don't know how to downcase. each method only works with certain methods. fixnums don't work or udnerstand downcase. but strings know what they mean.
- "kennyT".reverse.upcase is method chaining. both can do their thing and upcase works on upcase cuz <"kennyT".reverse> becomes a new string that .upcase recognizes.
